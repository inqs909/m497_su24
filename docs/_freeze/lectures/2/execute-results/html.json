{
  "hash": "bf72506f9e466da31a943cf123729db2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functional Programming\"\nformat:\n  revealjs:\n    scrollable: true\n    navigation-mode: vertical\n    controls-layout: bottom-right\n    controls-tutorial: true\n    incremental: false \n    chalkboard:\n      src: chalkboard.json\n      storage: chalkboard_pres\n      theme: whiteboard\n      chalk-width: 4\nengine: knitr\nknitr:\n  opts_chunk: \n    echo: true\n    eval: false\n    comment: \"#>\" \n\n\nrevealjs-plugins:\n  - verticator\n  \nfilters: \n  - reveal-header\n  - reveal-auto-agenda\n  - code-fullscreen\n  - webr\n\nwebr: \n  show-startup-message: true\n---\n\n\n## Homework\n\nHomework 1 is assigned and can be found here: http://m497.inqs.info/hw.html\n\n## Quarto Documentation\n\n``` default\nquarto use template inqs909/qs_hw\n```\n\n## Quarto Resources\n\n- <https://www.inqs.info/stat_comp/document.html>\n- <https://quarto.org/docs/output-formats/html-basics.html>\n\n\n# Nested `for` Loops\n\n## Nested `for` Loops\n\nNested `for` loops are `for` loops within another `for` loop. You can stack these loops as much as needed. Just make sure the index is different for each loop. The general format for a loop goes as follow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector_1){\n  for (ii in vector_2){\n    perform task\n  }\n}\n```\n:::\n\n\n## Example\n\nWithout using the `sd()` function, compute the standard deviation for each column of the matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(1000), nrow = 10)\n```\n:::\n\n\n$$\ns^2 = \\frac{1}{n-1}\\sum^n_{i=1}(x_i-\\bar x)^2\n$$\n\n## Example\n\n```{webr-r}\nx <- matrix(rnorm(1000), nrow = 10)\n```\n\n# `while` Loops\n\n## `while` Loops\n\nA while loop is a combination of a `for` loop and a `break` statement. The loop will continue indefinitely until a condition becomes false.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initial Condition\ncondition <- starting TRUE condition\n\nwhile (condition){\n  perform task\n  condition <- update condition\n}\n```\n:::\n\n\n## Example\n\nSimulate from a $N(0,1)$ distribution until you have 50 positive numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nn <- 0\npos_num <- c()\n\nwhile (n < 51){\n  x <- rnorm(1)\n  if (x > 0) {\n    pos_num <- c(pos_num, x)\n    n <- n + 1\n  }\n}\n\npos_num\n```\n:::\n\n\n## Example\n\nFind the value of $x$ where the function $y=1/x$ relative converges ($\\frac{|y_{old}-y_{new}|}{y_{old}}$) at a level of $10^-6$ as $x\\rightarrow \\infty$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndiff <- 10\nx <- 2\ny_old <- 1\nwhile (diff > 1e-6){\n  y_new <- 1 / x\n  diff <- abs(y_old - y_new) / y_old\n  x <- x + 1\n  y_old <- y_new\n}\n```\n:::\n\n\n## Example\n\nSimulate from a $Binom(1,.2)$ distribution until the sum of the random variables generated is 50.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsum_bin <- 0\nx <- c()\nwhile (sum_bin <51) {\n  x <- c(x, rbinom(1, 1, 0.2))\n  sum_bin <- sum(x)\n}\nsum_bin\nlength(x)\n```\n:::\n\n\n# More Examples\n\n## Example\n\n## Example\n\nUsing the code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(5000)\n```\n:::\n\n\nCreate a new vector containing all the positive values of `x`. The new vector should be less than 5000.\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnn <- length(x)\npos <- c()\nfor (i in 1:nn){\n  if (x[i] > 0) {\n    pos <- c(pos, x[i])\n  }\n}\npos\n```\n:::\n\n\n## Example\n\n$$\nf(x,y) = x^2 + y^2 + \\ln(x+y)\n$$\n\nFind all the values of $f(x,y)$ for every combination of $x \\in \\{1, 8, 13, 25, 42, 67, 95\\}$ and $y \\in \\{6, 12, 18, 52, 61, 79, 83\\}$\n\nStore values in a $7\\times 7$ matrix.\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nx <- c(1, 8, 13, 25, 42, 67, 95)\ny <- c(6, 12, 18, 52, 61, 79, 83)\nres <- matrix(nrow = 7, ncol = 7)\ncolnames(res) <- as.character(x)\nrownames(res) <- as.character(y)\n\nfor (i in 1:7){\n  for (ii in 1:7){\n    res[ii,i] <- x[i]^2 + y[ii]^2 + log(x[i] + y[ii])\n  }\n}\nprint(res)\n```\n:::\n\n\n# Vectorized Code\n\n## Vectorized Code\n\nVectorized code is programming where functions or processes are applied to vectors instead of individual values.\n\n::: fragment\nIndicating a loop is not necessary to apply a function to each individual element in a vector.\n:::\n\n## Vectorized Code\n\nMathematical Operations are conducted element-wise to 2 or more vectors\n\n::: fragment\nElement 1 in vector `x` is applied to element 1 in vector `y`\n:::\n\n## Example\n\n```{webr-r}\nx <- 1:20\npost <- vector(length = 20)\nfor (i in seq_along(x)){\n  post[i] <- sinpi(x[i])\n}\npost\n\n## OR\n\nsinpi(x)\n\n```\n\n## Example\n\n```{webr-r}\nx <- 1:5\ny <- 1:5\n```\n\n# Built-in Functions\n\n## Built-in Functions\n\nThere are several available functions in R to conduct specific statistical methods or tasks\n\n## Help Documentation\n\n| Section     | Description                                                 |\n|:---------------------|:-------------------------------------------------|\n| Description | Provides a brief introduction of the function               |\n| Usage       | Provides potential usage of the function                    |\n| Arguments   | Arguments that the function can take                        |\n| Details     | An in depth description of the function                     |\n| Value       | Provides information of the output produced by the function |\n| Notes       | Any need to know information about the function             |\n| Authors     | Developers of the function                                  |\n| References  | References to the model and function                        |\n| See Also    | Provide information of supporting functions                 |\n| Examples    | Examples of the function                                    |\n\n## Generic Functions\n\nSeveral R objects have a known class attached to it. A specialized object designed to be read by generic functions, such as `summary()` and `plot()`.\n\nFor example, the `summary()` is a generic for several types of functions: `summary.aov()`, `summary.lm()`, `summary.glm()`, and many more.\n\n## Commonly-used Function\n\n| Functions  | Description                 |\n|:-----------|:----------------------------|\n| `aov()`    | Fits an ANOVA Model         |\n| `lm()`     | Fits a linear model         |\n| `glm()`    | Fits a general linear model |\n| `t.test()` | Conducts a t-test           |\n\n# User-built functions\n\n## User-built functions\n\n-   Functions created by the user for analysis\n\n-   Needs to be ran once to the R environment\n\n-   Will be lost when R session is closed\n\n## Anatomy\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1-3|4-5|6|7\"}\nname_of_function <- function(data_1, data_2 = NULL, \n                             argument_1, argument_2 = TRUE, argument_3 = NULL,\n                             ...){\n  # Conduct Task\n  # Conduct Task\n  output_object <- Tasks\n  return(output_object)\n}\n```\n:::\n\n\n::: fragment\n-   `function`: used to construct the function\n\n-   `data1`: first data argument that needs to supplied\n\n-   `data2`: second data argument that does not need to be supplied\n\n-   `argument1`: first argument must be supplied to alter function\n\n-   `argument2`: second argument to alter function, set to `TRUE`\n\n-   `argument3`: third argument that does not need to be supplied\n\n-   `…`: additional arguments supplied to other functions\n:::\n\n## Example\n\nCreate a function for\n\n$$\ny = \\ln(x^2)\n$$\n\n## Example\n\nCreate a function for\n\n$$\nf(x) = \\left\\{\\begin{array}{cc}\nx^3 & x<0\\\\\nx^2 + 5 & \\mathrm{otherwise}\n\\end{array} \\right.\n$$\n\n## Example\n\nCreate a function for\n\n$$\nf(x,y) = \\left\\{\\begin{array}{cc}\nx^3 e^y &  x<0\\ \\\\\nx^2 + 5 + \\ln(y) & \\mathrm{otherwise}\n\\end{array} \\right.\n$$\n\n## Example\n\nCreate the function that allows your to compute the z-score of a specific value `x` using the sampling distribution from a set of data (`y` vector):\n\n$$\nz =  \\frac{x-\\bar y}{\\sqrt{s^2_{y}/n_y}}\n$$\n\n# `apply()`\n\n## `apply()`\n\nThe `apply` function returns a vector, array, or list of values by applying a function to the margins of an array. You will need to specify the following arguments:\n\n-   `X`: an array to be indexed and applied\n\n-   `MARGIN`: specifyng which index(es) to subset by\n\n-   `FUN`: function to be applied\n\n-   `…`: further arguments to be applied to `FUN`, must be labeled\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(X, MARGIN, FUN, ...)\n```\n:::\n\n\n## Example\n\nFind the standard deviation of all the columns of the following matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(1000), nrow = 10)\n```\n:::\n\n\n## Example\n\nFind the $25th$, $50th$, and $75th$ quartiles for each row of the following matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(1000), nrow = 20)\n```\n:::\n\n\n# `lapply()`\n\n## `lapply()`\n\nThe `lapply` function applies a function to all the elements of a vector or matrix, and it will return a list. You will need to specify the following arguments:\n\n-   `X`: object to be iterated\n\n-   `FUN`: a function to be applied\n\n-   `…`: further arguments to be passed along to `FUN`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X, FUN, ...)\n```\n:::\n\n\n## Example\n\nCreate a function that returns a labeled list for with the following values: mean, standard deviation, median, max, and min.\n\n# `sapply()`\n\n## `sapply()`\n\nThe `sapply()` function will apply a function to each element of a list or vector, and it will return a simplified object, vector, matrix, or array. The `sapply()` function uses 4 main arguments:\n\n-   `X`: a vector or list to be iterated\n\n-   `FUN`: a function to be applied\n\n-   `…`: arguments passed along to `FUN`, must be labeled\n\n-   `simplify`: indicates how to simplify the function, defaults to n-dimensional array based on output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(X, FUN, ..., simplify = TRUE)\n```\n:::\n\n\n## Example\n\nUsing the vector below, compute the length of each string using `sapply` and `str_length()` from `tidyverse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\", \"honeydew\", \"kiwi\", \"lemon\")\n```\n:::\n\n\n## Example\n\nUsing the list generated below, compute the mean of each element of the list using `sapply`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a list of 10 lists, each containing 5 random numbers\nlists <- lapply(1:10, function(i) {\n  means <- rpois(1, 3)\n  rnorm(5, means)\n})\n```\n:::\n\n\n## Example\n\nUsing the vector below, use the `sapply()` to find $\\log(x)$ for each value and return a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- 4:400\n```\n:::\n",
    "supporting": [
      "2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}