{
  "hash": "1f4b1ce238a3bdace04c5c33ff8a2ec6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulation Studies\"\nsubtitle: \"Zero Models\"\nformat:\n  revealjs:\n    include-in-header: \"math_commands.html\"\n    scrollable: true\n    navigation-mode: vertical\n    controls-layout: bottom-right\n    controls-tutorial: true\n    incremental: false \n    chalkboard:\n      src: chalkboard.json\n      storage: chalkboard_pres\n      theme: whiteboard\n      chalk-width: 4\nengine: knitr\nknitr:\n  opts_chunk: \n    code-fold: show\n    echo: true\n    eval: false\n    comment: \"#>\" \nfilters: \n  - reveal-header\n  - reveal-auto-agenda\n  - code-fullscreen\n  - webr\nwebr: \n  show-startup-message: true\n  packages: ['ggplot2', 'dplyr', 'stringr']\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## R Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(extraDistr)\nlibrary(mvtnorm)\nlibrary(splines2)\nlibrary(tidyverse)\nlibrary(brms)\ntheme_set(theme_bw())\n```\n:::\n\n\n\n\n# Zero-Inflated Models\n\n## Zero-Inflated Models\n\nZero-inflated models is a mixture model where random variables are generated from 2 or more distributions. \n\n::: fragment\nOn distribution that states the value came from 2 possible distributions. All other values could have come from a common distribution. \n:::\n\n::: fragment\n\n:::\n\n\n## Mixture Models\n\n$$\nf(x) = \\pi g(x) + (1-\\pi)h(x)\n$$\n\n-   $\\pi\\in(0,1)$\n\n## Zero-Inflated Distribution\n\nA zero-inflated distribution is a mixture model, where the observed value of 0 can com from 2 distributions.\n\n::: fragment\nThis forces the data to produce more 0's than from a standard distribution.\n:::\n\n\n## Zero-Inflated\n\n$$\nP(x=0) = \\left\\{\\begin{array}{cc}\n\\pi + (1-\\pi)g(x) & X=0 \\\\\n(1-\\pi)g(x) & otherwise\n\\end{array}\n\\right.\n$$\n\n## Modelling 0\n\nWhen modeling a ZI-model, we need to determine where the 0 came from.\n\n::: fragment\nThis is modeled using a Binary (logistic) GLM.\n:::\n\n## ZI-Poisson\n\nIf you believe that the data comes from a Poisson distribution, but there is an abnormal amount of 0's, It may indicate that 0 may come from 2 sources of distributions.\n\n::: fragment\nHence the Zero-inflated Poison model may be appropriate.\n:::\n\n## Simulating ZI-Poisson\n\n### Zero\n\n$$\ng(\\pi) = -1.85 + 1.1 X_1\n$$\n\n### Poisson\n\n$$\nh(\\lambda) = 4-2X_2\n$$\n\n## Simulating ZI-Poisson\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nn <- 10000\nx1 <- rnorm(n, mean = 2)\nx2 <- rnorm(n, mean = 2.5)\neta <- boot::inv.logit(-1.85 + 1.1 * x1)\nzi <- rbinom(n, size = 1, prob = eta)\nmu <- exp(4 - 2 * x2)\np <- rpois(n, mu)\ny <- (zi == 0) * p\n```\n:::\n\n\n\n## Bayesian Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbrm(bf(y ~ x2, \n       zi ~ x1), \n    data = tibble(y, x1, x2),\n    family = zero_inflated_poisson(),\n    cores = 4)\n```\n:::\n\n\n\n\n## ZI-Negative Binomial\n\nIf you believe that the data comes from a negative binomial distribution, but there is an abnormal amount of 0's, It may indicate that 0 may come from 2 sources of distributions.\n\n::: fragment\nHence the Zero-inflated Poison model may be appropriate.\n:::\n\n## Simulating ZI-Negative Binomial\n\n### Zero\n\n$$\ng(\\pi) = -1.85 + 1.1 X_1\n$$\n\n### Negative Binomial\n\n$$\nh(\\mu) = -0.85-1.3X_2\n$$\n\n## Simulating ZI-Negative Binomial\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nn <- 10000\nx1 <- rnorm(n, mean = 2)\nx2 <- rnorm(n)\neta <- boot::inv.logit(-1.85 + 1.1 * x1)\nzi <- rbinom(n, size = 1, prob = eta)\nmu <- exp(-0.85 + 1.3 * x2)\np <- rnbinom(n, mu = mu, size = 0.5)\ny <- (zi == 0) * p\n```\n:::\n\n\n\n## Bayesian Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbrm(bf(y ~ x2, \n       zi ~ x1), \n    data = tibble(y, x1, x2),\n    family = zero_inflated_negbinomial(),\n    cores = 4)\n```\n:::\n\n\n\n\n# Hurdle Models\n\n## Hurdle Models\n\nHurdle models are used to model data where the value 0 is believed to come from one distribution, and all the other values come from a separate distribution.\n\n::: fragment\nIt can be thought of as data points had to overcome a hurdle to escape 0 to obtain a different value.\n:::\n\n## Hurdle Models\n\n$$\nP(x=0) = \\left\\{\\begin{array}{cc}\n\\pi & X=0 \\\\\n(1-\\pi)g(x) & otherwise\n\\end{array}\n\\right.\n$$\n\n## ZI vs Hurdle\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n### Hurdle Models\n\n$$\n\\begin{array}{c}\n\\pi \\\\\n(1-\\pi)g(x)\n\\end{array}\n$$\n:::\n\n::: {.column width=\"50%\"}\n### ZI Models\n\n$$\n\\begin{array}{cc}\n\\pi + (1-\\pi)g(x) & X=0 \\\\\n(1-\\pi)g(x) & otherwise\n\\end{array}\n$$\n:::\n\n::::\n\n## Modelling 0\n\nWhen modeling a ZI-model, we need to determine where the 0 came from.\n\n::: fragment\nThis is modeled using a Binary (logistic) GLM.\n:::\n\n## Hurdle Models\n\n-   Poisson\n-   Negative Binomial Model\n-   Log-Normal\n-   Gamma\n\n## Simulating Hurdle Poisson\n\n### Zero\n\n$$\ng(\\pi) = 1.1 + 3.1 X\n$$\n\n### Poisson\n\n$$\nh(\\lambda) = 0.75+1.3X\n$$\n\n\n## Hurdle Poisson Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nn <- 10000\nx <- rnorm(n)\neta <- boot::inv.logit(1.1 + 3.1 * x)\nzi <- rbinom(n, 1, eta)\nmu <- exp(0.75 + 1.3 * x)\np <- rtpois(n, lambda = mu, a = 0)\ny <- (zi == 0) * p\n```\n:::\n\n\n\n## Bayesian Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbrm(bf(y ~ x,\n       hu ~ x),\n    data = tibble(y, x),\n    family = hurdle_poisson(),\n    cores = 4)\n```\n:::\n\n\n\n\n## Simulating Hurdle Gamma\n\n### Zero\n\n$$\ng(\\pi) = 1.1 + 3.1 X\n$$\n\n### Poisson\n\n$$\nh(\\lambda) = 0.75+1.3X\n$$\n\n## Hurdle Gamma Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nn <- 10000\nx <- rnorm(n, mean  = -0.25)\neta <- boot::inv.logit(1.1 + 3.1 * x)\nzi <- rbinom(n, 1, eta)\nmu <- exp(0.75 + 1.3 * x)\np <- rgamma(n, shape = 2, scale = mu / 2)\ny <- (zi == 0) * p\n```\n:::\n\n\n\n\n## Bayesian model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbrm(bf(y ~ x, \n       hu ~ x), \n    data = tibble(y, x),\n    family = hurdle_gamma(),\n    cores = 4)\n```\n:::\n\n\n\n\n# Cox Proportional Hazard Models\n\n## Cox Proportional Hazard Models\n\nCox proportional hazard model was used to model the association between a set of predictors and a time-to-event, in the presence of an independent censoring mechanism.\n\n## Data Type\n\n::: incremental\n-   Data is typically recorded as time-to-event data\n\n-   For biomedical studies, researchers are interested in time from diagnosis to death, known as time-to-death\n:::\n\n\n## Censoring\n\n::: incremental\n-   Censoring is a mechanism where we do not observe the true time-to-event\n\n-   Not all the time is observed\n\n-   Three common types of censoring mechanisms: *Right, Left,* and *Interval*\n:::\n\n## Left Censoring\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\ndat <- data.frame(ID = 1:10, \n                  t1 = c(7, 9, 10, 5, 5, 10, 5, 6, 6, 7) , \n                  censored = c(1, 1, 1, 0, 0, 1, 0, 1, 1, 1))\nggplot(dat, aes(x = ID, y = t1, shape = ifelse(censored, \"Death\", \"Censored\"))) + geom_point(size = 4) + \n    geom_linerange(aes(ymin = 0, ymax = t1)) +\n    geom_hline(yintercept = 5, lty = 2) +\n    coord_flip() + \n    scale_shape_manual(name = \"Event\", values = c(19, 15)) +\n    # ggtitle(\"Left Censoring\") + \n    xlab(\"Patient ID\") +  ylab(\"Months\") + \n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](9_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n\n## Data Construction\n\n::: incremental\n-   $T_i^*$: True time-to-event\n\n-   $C_i$: Censoring Time\n\n-   $T_i=\\min(T_i^*,C_i)$: Observed time-to-event\n\n-   $\\delta_i = I(T_i^*<C_i)$: Event indicator\n:::\n\n## Hazard Function\n\n$$\nh(t) = \\lim_{\\Delta t \\rightarrow 0} \\frac{P(t \\le T^* < t + \\Delta t \\mid T^* \\ge t)}{\\Delta t}\n$$\n\n## Proportional Hazard Model\n\n$$\nh(t \\mid \\boldsymbol X) = h_0(t) \\exp(\\boldsymbol\\beta^\\mathrm T\\boldsymbol X)\n$$\n-   $h_0(t)$: baseline hazard function\n\n-   $\\boldsymbol\\beta$: regression coefficients\n\n-   $\\boldsymbol X$: predictor variables\n\n## Simulated Model\n\n$$\nh(t \\mid \\boldsymbol X) = 1.5t^{0.5} \\exp(-1.5X_1 + 2.3X_2)\n$$\n$$\nC_i\\sim Exp(3.5)\n$$\n\n## Simulating Model\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nn <- 10000\ntdf <- tibble()\nfor (i in 1:10000){\n  phi <- 1.5\n  x.vec <- c(mvtnorm::rmvnorm(1,c(0,1.5),diag(c(1,.5))))\n  invS = function(t, u){\n    h = function(s) \n    {\n      phi * s^(phi - 1) * exp(-x.vec[1] * 1.5 + x.vec[2] * 2.3)\n    }     \n    \n    integrate(h, lower = 0, upper = t, subdivisions = 2000)$value + log(u)\t\t\t\n  }\n  u = runif(1)\n  Up <- 1\n  Root <- try(uniroot(invS, interval = c(0, Up), u = u)$root, TRUE)\n  while(inherits(Root, \"try-error\") | Root == 0) {\n    Up <- Up + 2\n    Root <- try(uniroot(invS, interval = c(0, Up), u = u)$root, TRUE)\n    if (Root == 0) {u <- runif(1)}\n  }\n  trueTimes <- if (!inherits(Root, \"try-error\")) Root else NA\n  \n  rateC = 3.5\n  Ctimes = rexp(1, rate = rateC)\n  \n  event.times = pmin(trueTimes, Ctimes,1)\n  delta_i = as.numeric(trueTimes <= min(Ctimes,1))\n  wdf <- tibble(x1 = x.vec[1], x2 = x.vec[2], time = event.times, censor = delta_i)\n  tdf <- bind_rows(tdf, wdf)\n}\n```\n:::\n\n\n\n## Bayesian Model\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nbrm(time | cens(1-censor) ~ x1 + x2,\n    data = tdf,\n    family = cox(),\n    cores = 4)\n```\n:::\n",
    "supporting": [
      "9_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}